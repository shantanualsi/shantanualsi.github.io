<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concepts on Shantanu Alshi</title>
    <link>http://localhost:1313/tags/concepts/</link>
    <description>Recent content in Concepts on Shantanu Alshi</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/concepts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fault Tolerance in Distributed Systems: Distributed Consensus</title>
      <link>http://localhost:1313/posts/fault-tolerance-in-ds-3/</link>
      <pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/fault-tolerance-in-ds-3/</guid>
      <description>&lt;p&gt;Back to writing after a while. Exam time! would try my best to stick around. Anyways, back to the topic-&lt;/p&gt;&#xA;&lt;p&gt;Welcome the most sought after and esoteric topics in distributed systems- Distributed Consensus! A plethora of algorithms and their variants have been proposed to solve this problem. This is a very rigorous subject and we will scratch the surface in this article. Note that this article will cover the topic from a systems standpoint. We will remain silent on the algorithmic viewpoint for now.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fault Tolerance in Distributed Systems: Timing Models</title>
      <link>http://localhost:1313/posts/fault-tolerance-in-ds-2/</link>
      <pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/fault-tolerance-in-ds-2/</guid>
      <description>&lt;p&gt;In the last post, I wrote about fault tolerance in Distributed Systems and how failure models are classified. This post will describe the timing models that need to be considered while studying fault tolerance.&lt;/p&gt;&#xA;&lt;p&gt;Roughly, a timing model is simply the way a distributed model behaves with respect to time.&lt;/p&gt;&#xA;&lt;h6 id=&#34;1-synchronous-timing-model&#34;&gt;1. Synchronous timing model &lt;a href=&#34;#1-synchronous-timing-model&#34; class=&#34;anchor&#34;&gt;ðŸ”—&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;Consider this model as a function where all the bounds (with respect to time) are known and are provided as arguments to the function. In this model, message delay is bounded and node processing speed is guaranteed. If the sender does not receive an acknowledgement after a certain period of time, either the message is considered lost, or the ACK is lost or the recipient node is considered dead or even experiencing a Byzantine failure. Of all these possibilities, if the communication channels are reliable, we are sure that there is a Node failure.This model helps in accurate failure detection.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fault Tolerance in Distributed Systems: Introduction</title>
      <link>http://localhost:1313/posts/fault-tolerance-in-ds-1/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/fault-tolerance-in-ds-1/</guid>
      <description>&lt;p&gt;Fault toleranceâ€”or the ability to handle any type of faultâ€”is a core motivation for distributed systems. This is one of the most widely studied topics in the area of Distributed Systems. If you are talking about a distributed environment of thousands of machines, it is evident that almost always, some will fail. Due to this very obvious fact, failures have become the norm rather than an exception.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
