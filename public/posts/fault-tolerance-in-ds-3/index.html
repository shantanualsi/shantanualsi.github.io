<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Fault Tolerance in Distributed Systems: Distributed Consensus | Shantanu Alshi</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="Back to writing after a while. Exam time! would try my best to stick around. Anyways, back to the topic-
Welcome the most sought after and esoteric topics in distributed systems- Distributed Consensus! A plethora of algorithms and their variants have been proposed to solve this problem. This is a very rigorous subject and we will scratch the surface in this article. Note that this article will cover the topic from a systems standpoint. We will remain silent on the algorithmic viewpoint for now.">
<meta name="generator" content="Hugo 0.149.1">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
  
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-C6SNRYL17D"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-C6SNRYL17D');
        }
      </script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">‚Üê</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Fault Tolerance in Distributed Systems: Distributed Consensus</h1>

    <div class="tip">
        <time datetime="2014-11-20 00:00:00 &#43;0000 UTC">Nov 20, 2014</time>
        <span class="split">
          ¬∑
        </span>
        <span>
          1242 words
        </span>
        <span class="split">
          ¬∑
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    


    <div class="content">
      <p>Back to writing after a while. Exam time! would try my best to stick around. Anyways, back to the topic-</p>
<p>Welcome the most sought after and esoteric topics in distributed systems- Distributed Consensus! A plethora of algorithms and their variants have been proposed to solve this problem. This is a very rigorous subject and we will scratch the surface in this article. Note that this article will cover the topic from a systems standpoint. We will remain silent on the algorithmic viewpoint for now.</p>
<p>First, lets see what do we mean by consensus. The fundamental problem in Distributed systems is that if a decision is to be made, all nodes in the system need to agree upon it. This is called consensus and is at the heart of many fault tolerance protocols. Let&rsquo;s look at some examples- The decision on the final write ordering for eventual consistency, decision on the instruction order in replicated state machine, Distributed commit for transactions, other voting scenarios etc.</p>
<p>You can think of consensus in a variety of trivial applications. Decide on the majority in case of voting, or decide OK only if everyone is OK in the case of distributed commit, or decide on any proposal as in case of write ordering.</p>
<p>Okay, I assume you got a hang of what I&rsquo;m talking about. Now let&rsquo;s see the four common versions of Distributed consensus in case of failures. There are four versions of this problems.</p>
<h4 id="version-1--node-crash-failures-channels-are-reliable-timing-is-synchronous">Version 1 = Node Crash Failures; Channels are reliable; Timing is Synchronous <a href="#version-1--node-crash-failures-channels-are-reliable-timing-is-synchronous" class="anchor">üîó</a></h4><p>Assume each node processes in lock-step rounds. One round is the time for receiving the input + local processing at the node + replying to the input. The consensus protocol for this scenario has been proved that consensus is deterministic only in the case when number of nodes is greater than <em>f+1</em> where f is the number of nodes prone to crash.</p>
<p>Now, the notion of &lsquo;round&rsquo; can be implemented only because the Timing is Synchronous, in other words, the values are bounded. Ideally, you cannot bound the local processing time. Think of it as this way- a request to crack a complex password using brute force technique would take a long time. It&rsquo;s still bound by a maximum value; however, not feasible enough to be considered for real world systems. Let&rsquo;s make this clear- the notion of round has an implicit assumption that the local processing time is not <em>too high</em> and is bounded by a value.</p>
<p><p class="markdown-image">
  <img src="/distributed-consensus.png" alt="Distributed Consensus"  />
</p></p>
<p>a,b,c are three processes. Remember- each process follows a lock step order (the horizontal dotted lines). Let&rsquo;s say Process b gives input as 1 to a and c. b sends 1 to a, and immediately fails before it sends to c. Now, a has seen {1,2,3}, however c only has seen {2,3}. A consensus at this step is clearly incorrect. Hence, there has to be another round in order to establish consensus. That is, we need one extra round for each node failure. In general, we need f+1 rounds for f failures.</p>
<p>So how much rounds does the system have to make in order to make a consensus? Simple- it depends on the system designer or can be addressed using even more sophisticated algorithms. [See Early stopping consensus algorithms]</p>
<p>Okay, I know your mind will be filled with endless questions at this point of time. How much local processing time is too high? How does the system know the point of consensus? There are algorithms to address this. But I&rsquo;ll stay away from those in this post.</p>
<h4 id="version-2---no-node-failures-channels-may-drop-messages-timing-is-synchronous-aka-coordinated-attack-problem">Version 2  = No node failures; Channels may drop messages; Timing is Synchronous (aka coordinated attack problem) <a href="#version-2---no-node-failures-channels-may-drop-messages-timing-is-synchronous-aka-coordinated-attack-problem" class="anchor">üîó</a></h4><p>There are two armies (nodes) A and B and want to attack at the same time. The goal is to reach an agreement whether to attack or not. If the decision is no, both A and B do not attack. If yes, both of them attack at the same time. There is a twist here- both A and B can communicate, however the messenger can die on the way, without getting delivered to the other army. Okay. now you know why this is called the coordinated attack problem.</p>
<p>Let&rsquo;s get straight to the point. Solving this consensus problem has been proved IMPOSSIBLE irrespective of the overhead you are willing to tolerate. Yes, you read it right.</p>
<h4 id="version-3---node-crash-failures-channels-are-reliable-timing-is-asynchronous">Version 3  = Node crash failures; Channels are reliable; Timing is Asynchronous <a href="#version-3---node-crash-failures-channels-are-reliable-timing-is-asynchronous" class="anchor">üîó</a></h4><p>This corresponds to a real life scenario.Consider the Internet. The famous FLP theorem proves that it is IMPOSSIBLE to have a deterministic protocol in this case that always terminates. If correctness is preserved, then we can always find some scenario where the problem does not guarantee liveness, in other words it does not terminate.</p>
<p>In practice, the Paxos protocol works for number of nodes n ‚â• 2f+1 where f is the number of crash failures possible. In this case, safety is always ensured (correctness). However, the protocol may enter into a livelock, which anyways always goes away eventually. Randomization can help to avoid livelock with probability 1. (Note that probability=1 DOES NOT mean &lsquo;certainly&rsquo;).</p>
<h4 id="version-4---node-byzantine-failures-channels-are-reliable-timing-is-synchronous-aka-the-byzantine-generals-problem">Version 4  = Node Byzantine failures; Channels are reliable; Timing is Synchronous (aka The Byzantine Generals Problem) <a href="#version-4---node-byzantine-failures-channels-are-reliable-timing-is-synchronous-aka-the-byzantine-generals-problem" class="anchor">üîó</a></h4><p>Here&rsquo;s the model- There are n members in an army trying to reach a consensus. Now here among the n, there are f generals that always try to deviate the group from reaching a consensus. Each member has a 0 or 1 input &ndash; attack or retreat. The eventual goal of the group is that all non-faulty nodes eventually reach a consensus (termination), all non-faulty nodes eventually decide on the same value (agreement) and the eventual agreement is tied to the input the nodes provide (validity).</p>
<p>One of the application of this can be in the Replicated State machine (Linearizability).</p>
<p>The proved theorem in this scenario states- If <em>n ‚â§ 3f</em> then the Byzantine consensus problem cannot be solved. There are protocols that exists for _n &gt; 3f. _However, I&rsquo;ll keep them out of scope of this article for now.</p>
<p>Okay, so we just now scratched the surface of the scenarios in case of distributed consensus. You might be wondering we have 3 different variables- Timing model (Synchronous/Asynchronous), Nodes (Reliable/Crash Failures/Byzantine Failures) and Channels (Reliable/ may drop messages). Quite normally, there are 2x3x2 = 12 possibilities right? Here&rsquo;s the complete table for you-</p>
<table>
  <thead>
      <tr>
          <th>Timing Model</th>
          <th>Node</th>
          <th>Channel</th>
          <th>Comment</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Synchronous</td>
          <td>Byzantine</td>
          <td>Drops Messages</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Synchronous</td>
          <td>Crash</td>
          <td>Drops Messages</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Asynchronous</td>
          <td>Byzantine</td>
          <td>Drops Messages</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Asynchronous</td>
          <td>Crash</td>
          <td>Drops Messages</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Asynchronous</td>
          <td>Reliable</td>
          <td>Drops Messages</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Asynchronous</td>
          <td>Byzantine</td>
          <td>Reliable</td>
          <td>Impossible to solve.</td>
      </tr>
      <tr>
          <td>Asynchronous</td>
          <td>Crash</td>
          <td>Reliable</td>
          <td>Version 4 (Impossible to solve)</td>
      </tr>
      <tr>
          <td>Synchronous</td>
          <td>Reliable</td>
          <td>Drops Messages</td>
          <td>Version 2 (Impossible to solve)</td>
      </tr>
      <tr>
          <td>Synchronous</td>
          <td>Byzantine</td>
          <td>Reliable</td>
          <td>Version 3 (Deterministic solution for n&gt;3f)</td>
      </tr>
      <tr>
          <td>Synchronous</td>
          <td>Crash</td>
          <td>Reliable</td>
          <td>Version 1 (Deterministic solution)</td>
      </tr>
  </tbody>
</table>
<p>Note that Crash failures are the most lenient types of failure. If Crash failures are impossible to solve, Byzantine failures are even more horrible! And also, if the channel is dropping messages, getting to a consensus is impossible no matter what.</p>
<p>To conclude, in this post I just introduced the general types of failures and the uncertain nature of distributed consensus in various scenarios.</p>
<p>This post was quite informal and I made some statements without introducing the formal proof and logic behind it. Proofs exists, but they are non-trivial, highly mathematical and beyond the scope of a simple explanation. Next post, I&rsquo;ll write briefly about recovery.</p>

    </div>

    
        <div class="tags">
            
                <a href="http://localhost:1313/tags/distributed-systems">distributed systems</a>
            
                <a href="http://localhost:1313/tags/concepts">concepts</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       ¬© Copyright 
       2025 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        
      </div>
    
</footer>



  </body>
</html>
