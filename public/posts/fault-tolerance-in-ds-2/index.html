<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Fault Tolerance in Distributed Systems: Timing Models | Shantanu Alshi</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="In the last post, I wrote about fault tolerance in Distributed Systems and how failure models are classified. This post will describe the timing models that need to be considered while studying fault tolerance.
Roughly, a timing model is simply the way a distributed model behaves with respect to time.
1. Synchronous timing model üîóConsider this model as a function where all the bounds (with respect to time) are known and are provided as arguments to the function. In this model, message delay is bounded and node processing speed is guaranteed. If the sender does not receive an acknowledgement after a certain period of time, either the message is considered lost, or the ACK is lost or the recipient node is considered dead or even experiencing a Byzantine failure. Of all these possibilities, if the communication channels are reliable, we are sure that there is a Node failure.This model helps in accurate failure detection.">
<meta name="generator" content="Hugo 0.149.1">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
  
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-C6SNRYL17D"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-C6SNRYL17D');
        }
      </script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">‚Üê</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Fault Tolerance in Distributed Systems: Timing Models</h1>

    <div class="tip">
        <time datetime="2014-10-29 00:00:00 &#43;0000 UTC">Oct 29, 2014</time>
        <span class="split">
          ¬∑
        </span>
        <span>
          333 words
        </span>
        <span class="split">
          ¬∑
        </span>
        <span>
          2 minute read
        </span>
    </div>

    
    


    <div class="content">
      <p>In the last post, I wrote about fault tolerance in Distributed Systems and how failure models are classified. This post will describe the timing models that need to be considered while studying fault tolerance.</p>
<p>Roughly, a timing model is simply the way a distributed model behaves with respect to time.</p>
<h6 id="1-synchronous-timing-model">1. Synchronous timing model <a href="#1-synchronous-timing-model" class="anchor">üîó</a></h6><p>Consider this model as a function where all the bounds (with respect to time) are known and are provided as arguments to the function. In this model, message delay is bounded and node processing speed is guaranteed. If the sender does not receive an acknowledgement after a certain period of time, either the message is considered lost, or the ACK is lost or the recipient node is considered dead or even experiencing a Byzantine failure. Of all these possibilities, if the communication channels are reliable, we are sure that there is a Node failure.This model helps in accurate failure detection.</p>
<h6 id="2-asynchronous-timing-model">2. Asynchronous timing model <a href="#2-asynchronous-timing-model" class="anchor">üîó</a></h6><p>This is the opposite of the Synchronous model where message delay is unbounded and node processing speed is not guaranteed. Theoretically, the message propagation delay may tend to infinity in case a node is retrying to establish connection with a failed node. Practically, considering the Internet as an example, although the delay can be bounded by high values (say 1 year), making a node wait for 1 year before it realises that the recipient has failed is impractical. Hence, message delay in the theoretical case and the Internet in the later are examples of Asynchronous models and closely mimic the real world scenarios. The sad part is that, these are very poor at failure detection that makes designing real distributed systems challenging.</p>
<p>We just saw two distinct timing models in addition to the failure models in the last post. It is extremely critical that you are clear about the failure model and timing models used in your system for algorithms for one model do not extend to other models.</p>
<p>Next, in series - Distributed Consensus</p>

    </div>

    
        <div class="tags">
            
                <a href="http://localhost:1313/tags/distributed-systems">distributed systems</a>
            
                <a href="http://localhost:1313/tags/concepts">concepts</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       ¬© Copyright 
       2025 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        
      </div>
    
</footer>



  </body>
</html>
